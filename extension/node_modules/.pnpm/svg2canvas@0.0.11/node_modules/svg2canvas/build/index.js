"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateDrawingFromSVG = exports.SVGDrawing = exports.Drawing = exports.blend = exports.ColorToHex = exports.parseColor = void 0;
function parseColor(col) {
    var is6DigitHex = /^\#(?:[0-9A-F]{6})$/i;
    if (!is6DigitHex.test(col))
        throw new Error("Color failed to match pattern: #DDDDDD!");
    return {
        r: Number.parseInt(col.substr(1, 2), 16),
        g: Number.parseInt(col.substr(3, 2), 16),
        b: Number.parseInt(col.substr(5, 2), 16)
    };
}
exports.parseColor = parseColor;
function ColorToHex(col) {
    return "#" + [col.r, col.g, col.b].map(function (x) {
        var hex = Math.round(x).toString(16);
        return (hex.length === 1 ? '0' + hex : hex);
    }).join('');
}
exports.ColorToHex = ColorToHex;
function blend(_a, _b, a) {
    var r1 = _a.r, g1 = _a.g, b1 = _a.b;
    var r2 = _b.r, g2 = _b.g, b2 = _b.b;
    return {
        r: r1 * a + r2 * (1 - a),
        g: g1 * a + g2 * (1 - a),
        b: b1 * a + b2 * (1 - a)
    };
}
exports.blend = blend;
var StyleNames = [
    ["fillStyle", "fill", "black"],
    ["strokeStyle", "stroke", "none"],
    ["globalAlpha", "opacity", ""],
    ["lineCap", "stroke-linecap", ""],
    ["lineDashOffset", "stroke-dashoffset", ""],
    ["lineJoin", "stroke-linejoin", ""],
    ["lineWidth", "stroke-width", "1"],
    ["miterLimit", "stroke-miterlimit", ""],
];
function stylesEqual(s1, s2) {
    var keys1 = Object.keys(s1);
    var keys2 = Object.keys(s2);
    if (keys1.length !== keys2.length)
        return false;
    return keys1.every(function (key, i) { return key == keys2[i] &&
        s1[key] == s2[key]; });
}
function parseStyles(element) {
    var style = {};
    for (var _i = 0, StyleNames_1 = StyleNames; _i < StyleNames_1.length; _i++) {
        var _a = StyleNames_1[_i], styleName = _a[0], name_1 = _a[1], defaultValue = _a[2];
        if (!styleName || !name_1)
            continue;
        var value = element.getAttribute(name_1) || defaultValue;
        if (!value)
            continue;
        style[styleName] = value;
    }
    return style;
}
var GeometryProperties = {
    "cx": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 0; }
    },
    "cy": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 0; }
    },
    "r": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 0; }
    },
    "rx": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (e) {
            var ry = e.getAttribute("ry");
            if (!ry || ry == "auto")
                return 0;
            var val = Number.parseFloat(ry);
            return isNaN(val) ? 0 : val;
        }
    },
    "ry": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (e) {
            var rx = e.getAttribute("rx");
            if (!rx || rx == "auto")
                return 0;
            var val = Number.parseFloat(rx);
            return isNaN(val) ? 0 : val;
        }
    },
    "x": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 0; },
    },
    "y": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 0; },
    },
    "width": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 100; },
    },
    "height": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 100; },
    },
    "x1": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 0; },
    },
    "y1": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 0; },
    },
    "x2": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 0; },
    },
    "y2": {
        parse: function (data) { return Number.parseFloat(data); },
        defaultValue: function (_) { return 0; },
    },
    "points": {
        parse: function (data) {
            return data.split(" ")
                .filter(function (s) { return s.length > 0; })
                .map(function (s) { return s.split(",")
                .map(function (v) { return Number.parseFloat(v); }); });
        },
        defaultValue: function (_) { return ""; },
    },
    "d": {
        parse: function (data) { return data; },
        defaultValue: function (_) { return undefined; }
    },
};
var Drawing = /** @class */ (function () {
    function Drawing(style, path) {
        var _a, _b;
        this.children = [];
        this.style = style;
        this.path = path;
        var is6DigitHex = /^\#(?:[0-9A-F]{6})$/i;
        if ((style === null || style === void 0 ? void 0 : style.fillStyle) && is6DigitHex.test(style.fillStyle)) {
            this.fillColor = parseColor(style.fillStyle);
            (_a = this.style) === null || _a === void 0 ? true : delete _a.fillStyle;
        }
        if ((style === null || style === void 0 ? void 0 : style.strokeStyle) && is6DigitHex.test(style.strokeStyle)) {
            this.strokeColor = parseColor(style.strokeStyle);
            (_b = this.style) === null || _b === void 0 ? true : delete _b.strokeStyle;
        }
    }
    Drawing.prototype.applyStyles = function (ctx, tint, tintAmount) {
        if (tintAmount === void 0) { tintAmount = 0.5; }
        if (!this.style)
            return;
        Object.entries(this.style).forEach(function (_a) {
            var k = _a[0], v = _a[1];
            if (!(k in ctx) || ctx[k] == v)
                return;
            ctx[k] = v;
        });
        if (this.strokeColor) {
            var col = (tint ? blend(this.strokeColor, tint, tintAmount) : this.strokeColor);
            ctx.strokeStyle = "rgb(" + col.r + ", " + col.g + ", " + col.b + ")";
        }
        if (this.fillColor) {
            var col = (tint ? blend(this.fillColor, tint, tintAmount) : this.fillColor);
            ctx.fillStyle = "rgb(" + col.r + ", " + col.g + ", " + col.b + ")";
        }
    };
    Drawing.prototype.addChild = function (child) {
        this.children.push(child);
    };
    Drawing.prototype.draw = function (ctx, tint, tintAmount) {
        if (tintAmount === void 0) { tintAmount = 0.5; }
        this.applyStyles(ctx, tint, tintAmount);
        if (this.path) {
            if (this.style && this.style.fillStyle != "none")
                ctx.fill(this.path);
            if (this.style && this.style.strokeStyle != "none")
                ctx.stroke(this.path);
        }
        this.children.forEach(function (d) { return d.draw(ctx); });
    };
    return Drawing;
}());
exports.Drawing = Drawing;
var SVGDrawing = /** @class */ (function () {
    function SVGDrawing(width, height) {
        this.children = [];
        this.width = width;
        this.height = height;
        this.invWidth = 1.0 / width;
        this.invHeight = 1.0 / height;
    }
    SVGDrawing.prototype.addChild = function (child) {
        this.children.push(child);
    };
    SVGDrawing.prototype.draw = function (ctx, x, y, width, height, tint, tintAmount) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (tintAmount === void 0) { tintAmount = 0.5; }
        ctx.save();
        ctx.translate(x, y);
        if (width != undefined || height != undefined) {
            var sw = width ? width * this.invWidth : (height * this.invHeight);
            var sh = height ? height * this.invHeight : (width * this.invWidth);
            ctx.scale(sw, sh);
        }
        this.children.forEach(function (d) { return d.draw(ctx, tint, tintAmount); });
        ctx.restore();
    };
    return SVGDrawing;
}());
exports.SVGDrawing = SVGDrawing;
var Shapes = {
    "rect": {
        attributes: ["x", "y", "width", "height", "rx", "ry"],
        parse: function (_a) {
            var x = _a[0], y = _a[1], width = _a[2], height = _a[3], rx = _a[4], ry = _a[5];
            var path = new Path2D();
            path.rect(x, y, width, height);
            return path;
        }
    },
    "circle": {
        attributes: ["cx", "cy", "r"],
        parse: function (_a) {
            var cx = _a[0], cy = _a[1], r = _a[2];
            var path = new Path2D();
            path.ellipse(cx, cy, r, r, 0, 0, 2 * Math.PI);
            return path;
        }
    },
    "ellipse": {
        attributes: ["cx", "cy", "rx", "ry"],
        parse: function (_a) {
            var cx = _a[0], cy = _a[1], rx = _a[2], ry = _a[3];
            var path = new Path2D();
            path.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
            return path;
        }
    },
    "line": {
        attributes: ["x1", "y1", "x2", "y2"],
        parse: function (_a) {
            var x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
            var path = new Path2D();
            path.moveTo(x1, y1);
            path.lineTo(x2, y2);
            return path;
        }
    },
    "polyline": {
        attributes: ["points"],
        parse: function (_a) {
            var points = _a[0];
            var path = new Path2D();
            for (var i = 0; i < points.length; i++) {
                var _b = points[i], x = _b[0], y = _b[1];
                if (i == 0)
                    path.moveTo(x, y);
                else
                    path.lineTo(x, y);
            }
            return path;
        }
    },
    "polygon": {
        attributes: ["points"],
        parse: function (_a) {
            var points = _a[0];
            var path = new Path2D();
            for (var i = 0; i < points.length; i++) {
                var _b = points[i], x = _b[0], y = _b[1];
                if (i == 0)
                    path.moveTo(x, y);
                else
                    path.lineTo(x, y);
            }
            path.closePath();
            return path;
        }
    },
    "path": {
        attributes: ["d"],
        parse: function (_a) {
            var d = _a[0];
            return new Path2D(d);
        }
    }
};
function CreateDrawingFromSVG(svg, globalStyle) {
    if (!svg)
        return undefined;
    // Make sure there is exactly 1 svg root
    var root = svg.getElementsByTagName("svg");
    if (!root || root.length == 0)
        throw new Error("Can't find root element `svg` in the given SVG document!");
    else if (root.length > 1)
        throw new Error("Invalid SVG XML! Can only have one root `svg` element.");
    // Get width/height of svg
    var width = root[0].getAttribute("width");
    if (!width)
        throw new Error("Failed to find SVG `width` attribute!");
    var height = root[0].getAttribute("height");
    if (!height)
        throw new Error("Failed to find SVG `height` attribute!");
    // Get non-null and supported elements
    var nodes = Array.from(root[0].children).filter(function (element) {
        if (!element)
            return false;
        var type = element.nodeName;
        if (!(type in Shapes)) {
            console.error("Unsupported SVG node type " + type + "! Please make an issue on http://github.com/OpenCircuits/svg2path2D/issues!");
            return false;
        }
        return true;
    });
    // Get shape (style and path) for each node
    var shapes = nodes.map(function (element) {
        var type = element.nodeName;
        var style = __assign(__assign({}, parseStyles(element)), globalStyle);
        var shape = Shapes[type];
        var attributes = shape.attributes.map(function (attribute) {
            var _a = GeometryProperties[attribute], parse = _a.parse, defaultValue = _a.defaultValue;
            var val = element.getAttribute(attribute);
            return (val ? parse(val) : defaultValue(element));
        });
        var path = shape.parse(attributes);
        return [style, path];
    });
    // Reduce the shapes into one path by style
    //  this is more efficient since we can group the stylings
    //  under one path and therefore 1 draw call
    var reducedShapes = shapes.reduce(function (acc, cur) {
        if (acc.length == 0)
            return [cur];
        var curStyle = cur[0], curPath = cur[1];
        var _a = acc[acc.length - 1], prevStyle = _a[0], prevPath = _a[1];
        if (stylesEqual(curStyle, prevStyle)) {
            var newPath = new Path2D(prevPath);
            newPath.addPath(curPath);
            return __spreadArrays(acc.slice(0, acc.length - 1), [[prevStyle, newPath]]);
        }
        return __spreadArrays(acc, [cur]);
    }, []);
    // Add each shape as a drawing to the root drawing
    var rootDrawing = new SVGDrawing(Number.parseFloat(width), Number.parseFloat(height));
    reducedShapes.forEach(function (_a) {
        var style = _a[0], path = _a[1];
        return rootDrawing.addChild(new Drawing(style, path));
    });
    return rootDrawing;
}
exports.CreateDrawingFromSVG = CreateDrawingFromSVG;
